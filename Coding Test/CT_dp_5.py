import sys
input = sys.stdin.readline

# N가지 종류의 화폐가 있고, 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 m원이 되도록 해라.
# (종류의 구분은 화폐의 구성으로만 구분한다.)

n, m = map(int,input().split()) # n = 화폐 종류 개수(1 <= n <= 100), m = 목표 금액(1 <= m <= 10,000)
coins = []

for _ in range(n):
    coins.append(int(input()))

dp = [10001] * (m+1)

dp[0] = 0
for coin in coins:
    for i in range(coin,m+1):
        dp[i] = min(dp[i], dp[i-coin] + 1)

if dp[m] == 10001:
    print(-1)
else:
    print(dp[m])

### 해설 ###

# 이 경우는 dp 테이블을 10001처럼 범위를 벗어나는 값을 설정한다. "dp[금액] = 필요한 화폐 개수" 의 형태로 저장되는 테이블이다. 

# 화폐를 하나씩 살펴보면서 테이블을 갱신하는 것이 핵심 포인트가 된다.

# 1. dp[0] = 0인 이유는, 0원을 만들기 위해서는 화폐 0개가 필요하기 때문에 0으로 저장해둔다. 모든 값은 dp[0]을 기반으로 도출될 수 밖에 없다.

# 2. 리스트 coins에 저장해놓은 coin(화폐)들을 돌면서 차례로 dp를 갱신해주는데, 점화식의 원리는 다음과 같다.

# 3. dp[i] = min(dp[i], dp[i-coin] + 1)의 뜻은, dp[i]의 값과 dp[i-coin] + 1 중 작은 것을 값으로 채택한다. 이것은 최소인 것으로 갱신해가기 위한 장치이다.

# 4. dp[i-coin]은 i-coin원을 만드는 데에 필요한 최소 개수이고, 여기에 +1을 하면 i원을 만드는 데에 필요한 최소 개수가 되고 이걸 기존의 값과 비교한다.
# (책의 예시: dp[0] = 0이고, dp[2]는 2원을 만들 때 2원짜리 하나만 필요하므로, 1이 된다.)

# 5. 즉 (i-coin)원까지 채워놓은 상태에서 coin만큼 더 채우면 i원이 되고, 갯수로는 1개가 추가되는 것이다.

# 6. 참고) dp 테이블의 값을 10001으로 초기화시켜놨고, 1 <= m <= 10,000 이므로 항상 m보다 크다. 그래서 처음에 값 갱신할 때도 조건을 달 필요가 없다.

# 7. 반복문이 끝난 후 dp의 값이 끝까지 10001로 남아있게 되면 주어진 화폐로는 해당 값을 만들 수가 없다는 의미이다.
